% Created 2021-01-28 Thu 17:47
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=1in]{geometry}
\author{Sudhan Chitgopkar}
\date{\today}
\title{Theory of Computing}
\hypersetup{
 pdfauthor={Sudhan Chitgopkar},
 pdftitle={Theory of Computing},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\maketitle
\tableofcontents \clearpage\section{01.28.29}
\label{sec:org7880746}
\subsection{Nondeterministic Finite Automata}
\label{sec:org1b57d0b}
\subsubsection{DFA Review}
\label{sec:org5bad897}
\begin{itemize}
\item DFA's are 5-tuples with
\begin{itemize}
\item \(\delta\): Q \texttimes{} \(\Sigma\) \(\to\) Q
\item The number of transitions, \(\delta\), is |Q||\(\Sigma\)|
\end{itemize}
\item There is no real decision-making here, an input is simply being used alongside a rule to find an output
\end{itemize}
\subsubsection{NFA's}
\label{sec:orgaf6f310}
\begin{itemize}
\item NFAs are also a 5-tuple
\item \(\delta\): Q \texttimes{} \(\Sigma\) \(\to\) \powerset{p}(Q)
\item |\mathbb{P}(Q)| = 2\textsuperscript{|Q|}
\end{itemize}
\section{01.26.21 - 01.28.20}
\label{sec:orga0827d5}
\subsection{Closure Introduction}
\label{sec:org9dd4d5c}
\begin{itemize}
\item The language recognized by a DFA, M, (L(M)) is the set of all string accepted by M
\item Thus, M = (Q, \(\Sigma\), \(\delta\), q\textsubscript{0},F)
\item And \(\Sigma\)* is the universe of all possible inputs to M
\item \(\forall\) strings w \(\in\) \(\Sigma\)*, M either accepts or rejects w
\item It follows that L(M) \(\subset\) \(\Sigma\)*
\item And \textlnot{} L(M) = \(\Sigma\)* - L(M)
\item Therefore, M accepts every string in L(M) and rejects everything in \textlnot{} L(M)
\end{itemize}
\subsection{Closure Continued}
\label{sec:orgd3dde2b}
\begin{itemize}
\item A set, A, is closed under a binary operation, OP, if \(\forall\) x , y \(\in\) A [x OP y \(\in\) A]
\item Ex. Natural Numbers (\(\mathbb{N}\))
\begin{enumerate}
\item \(\mathbb{N}\) is closed under +
\item \(\mathbb{N}\) is closed under \texttimes{}
\item \(\mathbb{N}\) is not closed under -
\item \(\mathbb{N}\) is not closed under $\backslash$
\end{enumerate}
\item The class of all languages that are recognized by DFAs is closed under \(\cup\)
\end{itemize}
\subsection{Closure Properties of DFAs}
\label{sec:org94a2565}
\begin{itemize}
\item Union (\(\cup\))
\item Intersection (\(\cap\))
\item Complement (\textlnot{})
\item Reverse
\end{itemize}
\subsection{Applying Closure Properties}
\label{sec:orgeb4f6ce}
\begin{itemize}
\item If L(M\textsubscript{1}) \(\cup\) L(M\textsubscript{2}) are DFAs, then \(\exists\) DFA, M, with L(M) = L(M\textsubscript{1}) \(\cup\) L(M\textsubscript{2})
\item The purpose of a state machine is to make a yes/no decision
\end{itemize}
\subsubsection{Premise:}
\label{sec:org1c18134}
\begin{itemize}
\item M\textsubscript{1} = \{Q\textsubscript{1},\(\Sigma\),\(\delta\)\textsubscript{1},q\textsubscript{0\textsubscript{1}},F\textsubscript{1}\} and M\textsubscript{2} = \{Q\textsubscript{2},\(\Sigma\),\(\delta\)\textsubscript{2},q\textsubscript{0},F\textsubscript{2}\} are DFAs
\item M\textsubscript{1} accepts binary strings ending in 1
\item M\textsubscript{2} accepts binary strings of odd length
\item L(M) = L(M\textsubscript{1}) \(\cup\) L(M\textsubscript{2})
\begin{itemize}
\item Accepts binary strings that either end in 1 OR have odd length (or both)
\end{itemize}
\item M\textsubscript{1}: q\textsubscript{1}, q\textsubscript{2} distinguished between ending in 0 and 1
\item M\textsubscript{2}: r\textsubscript{1}, r\textsubscript{2} distinguished between odd and even length
\item Accordingly, M must be able to distinguish between:
\begin{itemize}
\item even length ending in 1
\item even length ending in 0
\item odd length ending in 1
\item odd length ending in 0
\end{itemize}
\end{itemize}
\subsubsection{Coding M}
\label{sec:org56ffdc1}
\begin{itemize}
\item Consider Q = Q\textsubscript{1} \(\cdot\) Q\textsubscript{2} = \{q\textsubscript{1}r\textsubscript{1},q\textsubscript{2}r\textsubscript{1},q\textsubscript{1}r\textsubscript{2},q\textsubscript{2}r\textsubscript{2}\}
\item wherein
\begin{itemize}
\item q\textsubscript{1}r\textsubscript{1} = even string ending in 0
\item q\textsubscript{1}r\textsubscript{2} = odd string ending in 0
\item q\textsubscript{2}r\textsubscript{1} = even string ending in 1
\item q\textsubscript{2}r\textsubscript{2} = odd string ending in 1
\end{itemize}
\item Ex. \(\delta\)(q\textsubscript{1}r\textsubscript{1},1) = q\textsubscript{1}r\textsubscript{2}
\item Applying this logic to a DFA, we know that
\begin{itemize}
\item Q=\{q1r1,q1r2,q2r1,q2r2\};
\item S=\{0,1\};
\item d:Q $\backslash$*sigma \(\to\) Q;
\item d(q1r1,0)=q1r2;
\item d(q1r1,1)=q2r2;
\item d(q1r2,0)=q1r1;
\item d(q1r2,1)=q2r1;
\item d(q2r1,0)=q1r2;
\item d(q2r1,1)=q2r2;
\item d(q2r2,0)=q1r1;
\item d(q2r2,1)=q2r1;
\item q0=q1r1;
\item F=\{q1r2,q2r1,q2r2\};
\end{itemize}
\end{itemize}
\subsubsection{Derivation}
\label{sec:org8a01f2a}
\begin{itemize}
\item Construct M and show that L(M) = L(M\textsubscript{1}) \(\cup\) L(M\textsubscript{2}).
\item Q = Q\textsubscript{1} \(\cdot\) Q\textsubscript{2}
\item let q\textsubscript{i} \(\in\) Q\textsubscript{1} and let r\textsubscript{j} \(\in\) Q\textsubscript{2}. and let c \(\in\) \(\Sigma\)
\item and q\textsubscript{i}r\textsubscript{j} \(\in\) Q
\item thus, \(\delta\)( q\textsubscript{i}r\textsubscript{j},c) = \(\delta\)\textsubscript{1}(q\textsubscript{i},c)\(\delta\)\textsubscript{2}(r\textsubscript{j},c)
\item and q\textsubscript{0} = q\textsubscript{0}\textsubscript{1},q\textsubscript{0}\textsubscript{2}
\item so that F=\{q\textsubscript{i}r\textsubscript{j}: q\textsubscript{i} \(\in\) F\textsubscript{1} \(\cup\) r\textsubscript{j} \(\in\) F\textsubscript{2}\}
\end{itemize}
\subsubsection{Correctness}
\label{sec:org7c29eb2}
\begin{itemize}
\item Show that M accepts exactly the strings that are accepted by M\textsubscript{1} or M\textsubscript{2}
\item If w \(\in\) \(\Sigma\)*. tjem w is accepted by M and w is accepted by either M\textsubscript{1} or M\{2\}
\item To do this, we can organize \(\Sigma\)* into strings of length 0, length 1, length 2\ldots{}
\item We solve with mathematical induction, which is how we prove recurrence relationships
\end{itemize}
\subsubsection{Mathematical Induction}
\label{sec:orgd5dd2da}
\begin{itemize}
\item Need base case and induction hypothesis
\item Induction hypothesis says something is true about k, where k is the length of strings
\item \(\delta\)* (q\textsubscript{0},w) is the ending state of M on w where
\item \(\delta\)* (q\textsubscript{0},w) = \(\delta\)*\textsubscript{1}(q\textsubscript{0}\textsubscript{1},w)\(\delta\)*\textsubscript{2}(q\textsubscript{0}\textsubscript{2},w)
\item Induction Hypothesis: If |w| = k, then \(\delta\)*(q\textsubscript{0},w) \(\in\) F \iff \(\delta\)*\textsubscript{1}(q\textsubscript{0\textsubscript{1}},w) \(\in\) F\textsubscript{1} or \(\delta\)*\textsubscript{2}(q\textsubscript{0}\textsubscript{2},w) \(\inf\) F\textsubscript{2}
\item Let x \(\in\) \(\Sigma\).
\item Then |w \(\cdot\) x| = k+1
\item And \(\delta\)*(q\textsubscript{0,wx}) = \(\delta\)*\textsubscript{1}(q\textsubscript{0}\textsubscript{1},wx)\(\delta\)*\textsubscript{2}(q\textsubscript{0}\textsubscript{2},wx)
\item If \(\delta\)*\textsubscript{1}(q\textsubscript{0}\textsubscript{1},wx) \(\in\) F\textsubscript{1}, \(\delta\)*(q\textsubscript{0,wx}) \(\in\) F
\item Similarly, if delta*\textsubscript{2}(q\textsubscript{0}\textsubscript{2},wx), then \(\delta\)*(q\textsubscript{0,wx}) \(\in\) F
\end{itemize}
\section{01.21.21}
\label{sec:org28ee869}
\subsection{Deterministic Finite Automata}
\label{sec:org3b9dad3}
\begin{itemize}
\item We know that \(\delta\) = Q \texttimes{} \(\Sigma\) \(\to\) Q\textsubscript{2}
\item We want a function that takes a starting state and a string, then returns the state after the machine has read that string
\item Let's define \(\delta\)* = Q \texttimes{} \(\Sigma\)* \(\to\) Q
\begin{itemize}
\item \(\delta\)* takes a state and a string
\item \(\delta\) takes a state and a symbol
\end{itemize}
\item Now, we need a recursive definition
\begin{itemize}
\item Base case:
\begin{itemize}
\item Let q\textsubscript{i} \(\in\) Q
\item \(\delta\)*(q\textsubscript{i},\(\epsilon\)) = q\textsubscript{i}
\end{itemize}
\item Recursive step:
\begin{itemize}
\item If q\textsubscript{i} \(\in\) Q, w \(\in\) \(\Sigma\)*, and c \(\in\) \(\Sigma\)
\item then \(\delta\)*(q, w \(\cdot\) c) = \(\delta\)(\(\delta\)*(q\textsubscript{i},w),c)
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Aside: On \(\Sigma\) and \(\Sigma\)*}
\label{sec:orgb9441aa}
\begin{itemize}
\item \(\Sigma\)* is the universe of all strings over \(\Sigma\)
\begin{itemize}
\item \(\Sigma\) = \{0,1\}
\item \(\Sigma\)* = \{\(\epsilon\),0,1,00,01,11,10,000,\ldots{}\}
\end{itemize}
\item We can see this recursively
\begin{itemize}
\item Base step: \(\epsilon\) \(\in\) \(\Sigma\)*
\item Recursive step:
\item Let w \(\in\) \(\Sigma\)*, let c \(\in\) \(\Sigma\)
\item Then w \texttimes{} c \(\in\) \(\Sigma\)*
\end{itemize}
\item We can see this recursion graphically
\end{itemize}
\begin{center}
\begin{tabular}{lrrl}
w & c & w \(\cdot\) c & step\\
\hline
\(\epsilon\) &  & - & base\\
\(\epsilon\) & 1 & 1 & recursive\\
1 & 0 & 10 & recursive\\
10 & 1 & 101 & recursive\\
\end{tabular}
\end{center}
\subsection{Recursively Testing 101}
\label{sec:orgf9ddae8}
\begin{itemize}
\item Solve \(\delta\)*(q\textsubscript{1},101)
\item \(\delta\)(\(\delta\)*(q\textsubscript{1},10),1)
\item \(\delta\)*(q\textsubscript{1},10)
\item \(\delta\)(\(\delta\)*(q\textsubscript{1},1),0)
\end{itemize}
\subsubsection{{\bfseries\sffamily TODO} Complete Recursion Sequence}
\label{sec:org1cc997a}
\section{01.19.21}
\label{sec:orgca4c934}
\subsection{Tuples \& DFAs}
\label{sec:orgfd6149f}
\begin{itemize}
\item Tuples are sequences which are always finite in length
\item The deterministic finite automaton shown is a 5-tuple:
\begin{enumerate}
\item Q: finite nonempty set of states
\begin{itemize}
\item state: configuration of logic of a machine
\end{itemize}
\item \(\Sigma\) (Sigma) - input alphabet
\begin{itemize}
\item alphabet: a finite, nonempty set of symbols where symbols are an object of length 1
\end{itemize}
\item \(\delta\) (Delta) - transition function
\item Q\textsubscript{0} \(\in\) Q - starting state
\item F \(\subset\) Q - set of final states
\end{enumerate}
\item For this deterministic finite automaton,
\begin{itemize}
\item \(\delta\): Q \texttimes{} \(\Sigma\) \(\to\) Q\textsubscript{2}
\end{itemize}
Represented as a table,
\end{itemize}
\begin{center}
\begin{tabular}{rlrl}
Step & State & Input & Transition\\
\hline
1 & Q\textsubscript{1} & 1 & Q\textsubscript{1} \(\to\) Q\textsubscript{2}\\
2 & Q\textsubscript{2} & 0 & Q\textsubscript{2} \(\to\) Q\textsubscript{1}\\
3 & Q\textsubscript{1} & 1 & Q\textsubscript{1} \(\to\) Q\textsubscript{2}\\
4 & Q\textsubscript{2} & 1 & Q\textsubscript{2} \(\to\) Q\textsubscript{2}\\
\end{tabular}
\end{center}
\subsection{Domains \& Codomains}
\label{sec:org6cd3f36}
\begin{itemize}
\item Domain: set of all possible function inputs
\item Codomain: set of all possible outputs
\end{itemize}
\subsection{Strings}
\label{sec:org2212daa}
\begin{itemize}
\item In computer science, strings are character arrays
\item In mathematics, strings are sequences of symbols
\item Specifically a string over an alphabet, \(\Sigma\), is a sequence of symbols belonging to \(\Sigma\)
\item \(\epsilon\) is the empty string
\item Concatenation: If w\textsubscript{1}, w\textsubscript{2} \(\in\) \(\Sigma\), w\textsubscript{1} \(\cdot\) w\textsubscript{2} = w\textsubscript{1}w\textsubscript{2}
\item If c \(\in\) \(\Sigma\), then \(\epsilon\) \(\cdot\) c = c \(\cdot\) \(\epsilon\) = c
\end{itemize}
\subsection{{\bfseries\sffamily TODO} Review Recursive Definitions}
\label{sec:org7c231af}
\begin{itemize}
\item Base step: a step that can not be broken down any further, a fact that is always true regardless of the input
\item Recursive step:
\item Defining the length of a string over \(\Sigma\)
\begin{itemize}
\item Base: |\(\epsilon\)| = 0
\item Recursive:
\begin{itemize}
\item let w be a string over \(\Sigma\), and c \(\in\) \(\Sigma\)
\item then |w \(\cdot\) c| = |w| + 1
\end{itemize}
\end{itemize}
\item Using this to define |1011|,
\begin{enumerate}
\item |1011| = |101 \(\cdot\) 1| = |101| + 1 =
\item |10 \(\cdot\) 1| + 1 = |10| + 1 + 1 =
\item |1 \(\cdot\) 0| + 1 + 1 = |1| + 1 + 1 + 1 =
\item |\(\epsilon\) \(\cdot\) 1| + 1 + 1 + 1 =
\item |\(\epsilon\)| + 1 + 1 + 1 + 1 =
\item 0 + 1 + 1 + 1 + 1 = 4
\end{enumerate}
\end{itemize}
\subsection{Languages}
\label{sec:orgc15494f}
\begin{itemize}
\item Languages over \(\Sigma\) - a set of finite strings over \(\Sigma\)
\item Langauges recognized by an automaton, M, L(M) is the language accepted by M
\item \(\emptyset\) is the empty language
\item \(\epsilon\) \(\neq\) \(\emptyset\)
\item \(\epsilon\) \(\neq\) \{\(\epsilon\)\}
\item \(\epsilon\) is not a symbol in any alphabet
\end{itemize}
\section{01.14.21}
\label{sec:orgf7e08fe}
\subsection{Automaton (automata)}
\label{sec:org085ee65}
\begin{itemize}
\item Self running machine requiring a continuous power source
\begin{itemize}
\item Historically used power sources include water, steam, and electricity
\end{itemize}
\item Course revolves around defining the mathematics powering machines
\end{itemize}
\subsection{The Mathematics of Automata}
\label{sec:orgf21f6fd}
\subsubsection{Mathematicians \& History}
\label{sec:orgda89913}
\begin{itemize}
\item Cantor defines sets as collections of objects
\item Cantor also argues that infinites can be of different magnitudes - there are infinitely more real numbers than natural numbers
\item Goedel eventually derives his incompleteness theorem
\begin{itemize}
\item No logical system that contains the natural numbers can prove its own soundness
\item Every sound logical system containing the natural numbers contains valid statements that cannot be proved or disproved
\end{itemize}
\item In 1936, Turing proves The Halting Problem is not decidable, it is impossible
\begin{itemize}
\item The Halting Problem is an algorithm that can analyze any other algorithm and determine whether or not it goes into an infinite loop
\end{itemize}
\item Turing creates the turing machine as an object consisting of sets and processes wherein the object can use any finite process to complete an action.
\item Turing machine sets the basis for a computer, which leads to a series of important questions:
\begin{itemize}
\item What can \& can't a machine do?
\item What does it mean for a problem ot be harder than another?
\item What does it mean for a machine to be more powerfule than another?
\end{itemize}
\end{itemize}
\subsubsection{Sequential Logic}
\label{sec:org43304f5}
\begin{itemize}
\item Sentential Logic- based on boolean results
\begin{itemize}
\item Predicated on AND, OR, NOT
\item XOR, XAND, etc. can be derived using the above
\end{itemize}
\end{itemize}
\subsection{Necessary Review}
\label{sec:orgfc3534b}
\begin{itemize}
\item Textbook Ch. 0
\item Logic Statements
\item Set Theory
\item Functions
\end{itemize}
\subsection{Functions}
\label{sec:org858b2fd}
\begin{itemize}
\item Functions - something that maps objects from one set to another
\item Given f: a \(\to\) b;
\begin{itemize}
\item Everything in a is mapped to something in b
\begin{itemize}
\item For every x, such that x is an element of a, there exists a y, such that y is an element of b
\end{itemize}
\item No one point in the domain can be mapped to two different points in the codomain
\begin{itemize}
\item Logically, you can't have a function that takes in one input and returns two different outputs
\item If f maps x \(\to\) y1 and \(\to\) y2, y1 = y2
\end{itemize}
-\(\forall\) x \(\in\) A y\textsubscript{1},y\textsubscript{2} \(\in\) B [f(x)=y\textsubscript{1} \(\land\) f(x)=y\textsubscript{2} \(\to\) y\textsubscript{1} = y\textsubscript{2}]
\end{itemize}
\end{itemize}
\subsection{{\bfseries\sffamily TODO} Types of Functions - Definition \& Logical Statement}
\label{sec:org25d566d}
\begin{itemize}
\item Injective Functions
\item Surjective Functions
\item Proof by Induction (\(\forall\))
\item Proof by Contradiction (\textlnot{}\(\exists\))
\end{itemize}
\subsection{Finite Automaton (Finite State Machine)}
\label{sec:orge1149e3}
\begin{itemize}
\item States are logical confirgurations
\item States are generally based upon input
\item Purpose of a state machine is to make a yes/no decision
\end{itemize}
\end{document}
