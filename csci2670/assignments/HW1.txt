_ Sudhan Chitgopkar HW 1
__ Q1:
\+ fa
{
title="M_1";
Q={q0,q1};
S={0,1};
d:Q\*S->Q;
d(q0,0)=q0;
d(q0,1)=q1;
d(q1,0)=q0;
d(q1,1)=q1;
q0=q0;
F={q0};
}
__ Q2:
\+ fa
{
title="M_2";
Q={r0,r1,r2,r3};
S={0,1};
d:Q\*S->Q;
d(r0,0)=r1;
d(r0,1)=r1;
d(r1,0)=r2;
d(r1,1)=r2;
d(r2,0)=r3;
d(r2,1)=r3;
d(r3,0)=r3;
d(r3,1)=r3;
q0=r0;
F={r2};
}
__ Q3:
{w_0 \in \S* | w_0 does not end with 1}
__ Q4:
{w_1 \in \S* | w_1 is of length 2}
__ Q5:
{w \in \S* | w does not end with 1 \u is of length 2}
__ Q6:
\+ fa
{
title="M";
Q={q0r0,q0r1,q0r2,q0r3,q1r0,q1r1,q1r2,q1r3};
S={0,1};
d:Q\*S->Q;
d(q0r0,0)=q0r1;
d(q0r0,1)=q1r1;
d(q0r1,0)=q0r2;
d(q0r1,1)=q1r2;
d(q0r2,0)=q0r3;
d(q0r2,1)=q1r3;
d(q0r3,0)=q0r3;
d(q0r3,1)=q1r3;
d(q1r0,0)=q0r1;
d(q1r0,1)=q1r1;
d(q1r1,0)=q0r2;
d(q1r1,1)=q1r2;
d(q1r2,0)=q0r3;
d(q1r2,1)=q1r3;
d(q1r3,0)=q0r3;
d(q1r3,1)=q1r3;
q0=q0r0;
F={q0r0,q0r1,q0r2,q0r3,q1r2};
}
__ Q7:
Yes, q1r0 is an unnecessary state
__ Q8:
___ (a)
q1r0 is an unnecessary state as it is unreachable. Specifically, q1r0 is neither a starting state, nor has an transitions leading to it meaning that the DFA can never reach it.
__ (b)
The union algorithm produced unnecessary states because it forces the DFA produced by the union to have all possible combinations of the states which it is combining, even when these states are sometimes unnecessary.
___ (c)
Some states produced by the union algorithm are unnecessary because they simply aren't possible. Consider state q1r0 from the above problem. Because q1 means that the machine ends in a 1, and r0 means that this input is of length 0, q1r0 is contradictory as an input can not end in 1 and still be of size 0. It is through creation of impossible states like these that the union algorithm produces unnecessary states.
__ Q9:
\+ fa
{
title="M";
Q={q0r0,q0r1,q0r2,q0r3,q1r1,q1r2,q1r3};
S={0,1};
d:Q\*S->Q;
d(q0r0,0)=q0r1;
d(q0r0,1)=q1r1;
d(q0r1,0)=q0r2;
d(q0r1,1)=q1r2;
d(q0r2,0)=q0r3;
d(q0r2,1)=q1r3;
d(q0r3,0)=q0r3;
d(q0r3,1)=q1r3;
d(q1r1,0)=q0r2;
d(q1r1,1)=q1r2;
d(q1r2,0)=q0r3;
d(q1r2,1)=q1r3;
d(q1r3,0)=q0r3;
d(q1r3,1)=q1r3;
q0=q0r0;
F={q0r0,q0r1,q0r2,q0r3,q1r2};
}
__ Q10:
\+ fa
{
title="Q10";
Q={q1r1,q1r2,q1r3,q2r1,q2r2,q2r3,q3r1,q3r2,q3r3};
S={0,1};
d:Q\*S->Q;
d(q1r1,0)=q1r3;
d(q1r1,1)=q2r2;
d(q1r2,0)=q1r1;
d(q1r2,1)=q2r2;
d(q1r3,0)=q1r2;
d(q1r3,1)=q2r3;
d(q2r1,0)=q3r3;
d(q2r1,1)=q2r2;
d(q2r2,0)=q3r1;
d(q2r2,1)=q2r2;
d(q2r3,0)=q3r2;
d(q2r3,1)=q2r3;
d(q3r1,0)=q1r3;
d(q3r1,1)=q3r2;
d(q3r2,0)=q1r1;
d(q3r2,1)=q3r2;
d(q3r3,0)=q1r2;
d(q3r3,1)=q3r3;
q0=q1r1;
F={q2r1,q3r1};
}
__ Q11:
This DFA, M, which recognizes L(M_1) \n L(M_2) differs from a DFA that recognizes L(M_1) \u L(M_2) in terms of its accepting states.

Specifically, this machine, M, may only have final states that are the intersection of an accepting state in M_1 and an accepting state in M_2. A DFA that recognizes L(M_1) \u L(M_2), however, may have final states that are the intersection of an accepting state in M_1 and any state in M_2 or any state in M_1 and an accepting state in M_2.

__ Q12:
___ (a)
\+ accseq
{
q1r1\to[0]q1r3\to[0]q1r2\to[1]q2r2\to[0](q3r1)
}
___ (b)
\+ accseq
{
q1r1\to[1]q2r2\to[1]q2r2\to[1]q2r2\to[0](q3r1)
}
__ Q13:
___ (a)
\+ rejseq
{
q1r1\to[1]q2r2\to[0]q3r1\to[1]q3r2\to[0]:q1r1:
}
___ (b)
\+ rejseq
{
q1r1\to[0]q1r3\to[1]q2r3\to[0]q3r2\to[1]q3r2\to[0]:q1r1:

}
__ Q14:
\+ fa
{
title="Q14";
Q={q1,q2,q3,q4,q5,q6};
S={a,b};
d:Q\*S->Q;
d(q1,a)=q2;
d(q1,b)=q3;
d(q2,a)=q1;
d(q2,b)=q6;
d(q3,b)=q4;
d(q3,a)=q6;
d(q4,b)=q5;
d(q4,a)=q6;
d(q5,b)=q3;
d(q5,a)=q6;
d(q6,a)=q6;
d(q6,b)=q6;
q0=q1;
F={q1,q5};
}

__ Q15:
\+ fa
{
title="Q15";
Q={q1,q2,q3};
S={0,1}
d:Q\*S->Q
d(q1,0)=q1;
d(q1,1)=q2;
d(q2,0)=q3;
d(q2,1)=q2;
d(q3,0)=q1;
d(q3,1)=q3;
q0=q1;
F={q1};
}
__ Q16:
The DFA built in question 15 recognizes the correct language (complement of L(M_1)). This is because all finishing states in M_1 have been converted to non-finishing states, and all non-finishing states have been converted to finishing states.

This conversion of finishing states to non-finishing states and vice versa is critical, as any state previously accepted can no longer be accepted as it no longer resides in a finishing state. Similarly, any previously rejected input is now accepted as that same input will now reside in a finishing state. Because this means that all previously accepted input is now rejected and all previously rejected input is now accepted, the DFA presented in question 15 is a complement of L(M_1) and recognizes the correct language.
