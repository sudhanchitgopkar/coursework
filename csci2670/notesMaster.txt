Sudhan Chitgopkar


Table of Contents
_________________

1. 01.21.21
.. 1. Deterministic Finite Automata
.. 2. Aside: On Sigma and Sigma*
.. 3. Recursively Testing 101
2. 01.19.21
.. 1. Tuples & DFAs
.. 2. Domains & Codomains
.. 3. Strings
.. 4. TODO Review Recursive Definitions
.. 5. Languages
3. 01.14.21
.. 1. Automaton (automata)
.. 2. The Mathematics of Automata
..... 1. Mathematicians & History
..... 2. Sequential Logic
.. 3. Necessary Review
.. 4. Functions
.. 5. TODO Types of Functions - Definition & Logical Statement
.. 6. Finite Automaton (Finite State Machine)


1 01.21.21
==========

1.1 Deterministic Finite Automata
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - We know that delta = Q * Sigma -> Q_{2}
  - We want a function that takes a starting state and a string, then
    returns the state after the machine has read that string
  - Let's define delta* = Q * Sigma* -> Q
    - delta* takes a state and a string
    - delta takes a state and a symbol
  - Now, we need a recursive definition
    - Base case:
      - Let q_{i} [element of] Q
      - delta*(q_{i},epsilon) = q_{i}
    - Recursive step:
      - If q_{i} [element of] Q, w [element of] Sigma*, and c [element
        of] Sigma
      - then delta*(q, w [dot] c) = delta(delta*(q_{i},w),c)


1.2 Aside: On Sigma and Sigma*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - Sigma* is the universe of all strings over Sigma
    - Sigma = {0,1}
    - Sigma* = {epsilon,0,1,00,01,11,10,000,...}
  - We can see this recursively
    - Base step: epsilon [element of] Sigma*
    - Recursive step:
    - Let w [element of] Sigma*, let c [element of] Sigma
    - Then w * c [element of] Sigma*
  - We can see this recursion graphically
   w        c  w [dot] c  step      
  ----------------------------------
   epsilon             -  base      
   epsilon  1          1  recursive 
   1        0         10  recursive 
   10       1        101  recursive 


1.3 Recursively Testing 101
~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - Solve delta*(q_{1},101)
  - delta(delta*(q_{1},10),1)
  - delta*(q_{1},10)
    - delta(delta*(q_{1},1),0)


2 01.19.21
==========

2.1 Tuples & DFAs
~~~~~~~~~~~~~~~~~

  - Tuples are sequences which are always finite in length
  - The deterministic finite automaton shown is a 5-tuple:
    1. Q: finite nonempty set of states
       - state: configuration of logic of a machine
    2. Sigma (Sigma) - input alphabet
       - alphabet: a finite, nonempty set of symbols where symbols are
         an object of length 1
    3. delta (Delta) - transition function
    4. Q_{0} [element of] Q - starting state
    5. F [subset of] Q - set of final states
  - For this deterministic finite automaton,
    + delta: Q * Sigma -> Q_{2}
    Represented as a table,
     Step  State  Input  Transition     
        1  Q_{1}      1  Q_{1} -> Q_{2} 
        2  Q_{2}      0  Q_{2} -> Q_{1} 
        3  Q_{1}      1  Q_{1} -> Q_{2} 
        4  Q_{2}      1  Q_{2} -> Q_{2}


2.2 Domains & Codomains
~~~~~~~~~~~~~~~~~~~~~~~

  - Domain: set of all possible function inputs
  - Codomain: set of all possible outputs


2.3 Strings
~~~~~~~~~~~

  - In computer science, strings are character arrays
  - In mathematics, strings are sequences of symbols
  - Specifically a string over an alphabet, Sigma, is a sequence of
    symbols belonging to Sigma
  - epsilon is the empty string
  - Concatenation: If w_{1}, w_{2} [element of] Sigma, w_{1} [dot] w_{2}
    = w_{1}w_{2}
  - If c [element of] Sigma, then epsilon [dot] c = c [dot] epsilon = c


2.4 TODO Review Recursive Definitions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - Base step: a step that can not be broken down any further, a fact
    that is always true regardless of the input
  - Recursive step:
  - Defining the length of a string over Sigma
    - Base: |epsilon| = 0
    - Recursive:
      - let w be a string over Sigma, and c [element of] Sigma
      - then |w [dot] c| = |w| + 1
  - Using this to define |1011|,
    1) |1011| = |101 [dot] 1| = |101| + 1 =
    2) |10 [dot] 1| + 1 = |10| + 1 + 1 =
    3) |1 [dot] 0| + 1 + 1 = |1| + 1 + 1 + 1 =
    4) |epsilon [dot] 1| + 1 + 1 + 1 =
    5) |epsilon| + 1 + 1 + 1 + 1 =
    6) 0 + 1 + 1 + 1 + 1 = 4


2.5 Languages
~~~~~~~~~~~~~

  - Languages over Sigma - a set of finite strings over Sigma
  - Langauges recognized by an automaton, M, L(M) is the language
    accepted by M
  - [empty set] is the empty language
  - epsilon [not equal to] [empty set]
  - epsilon [not equal to] {epsilon}
  - epsilon is not a symbol in any alphabet


3 01.14.21
==========

3.1 Automaton (automata)
~~~~~~~~~~~~~~~~~~~~~~~~

  - Self running machine requiring a continuous power source
    - Historically used power sources include water, steam, and
      electricity
  - Course revolves around defining the mathematics powering machines


3.2 The Mathematics of Automata
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

3.2.1 Mathematicians & History
------------------------------

  - Cantor defines sets as collections of objects
  - Cantor also argues that infinites can be of different magnitudes -
    there are infinitely more real numbers than natural numbers
  - Goedel eventually derives his incompleteness theorem
    - No logical system that contains the natural numbers can prove its
      own soundness
    - Every sound logical system containing the natural numbers contains
      valid statements that cannot be proved or disproved
  - In 1936, Turing proves The Halting Problem is not decidable, it is
    impossible
    - The Halting Problem is an algorithm that can analyze any other
      algorithm and determine whether or not it goes into an infinite
      loop
  - Turing creates the turing machine as an object consisting of sets
    and processes wherein the object can use any finite process to
    complete an action.
  - Turing machine sets the basis for a computer, which leads to a
    series of important questions:
    - What can & can't a machine do?
    - What does it mean for a problem ot be harder than another?
    - What does it mean for a machine to be more powerfule than another?


3.2.2 Sequential Logic
----------------------

  - Sentential Logic- based on boolean results
    - Predicated on AND, OR, NOT
    - XOR, XAND, etc. can be derived using the above


3.3 Necessary Review
~~~~~~~~~~~~~~~~~~~~

  - Textbook Ch. 0
  - Logic Statements
  - Set Theory
  - Functions


3.4 Functions
~~~~~~~~~~~~~

  - Functions - something that maps objects from one set to another
  - Given f: a -> b;
    - Everything in a is mapped to something in b
      - For every x, such that x is an element of a, there exists a y,
        such that y is an element of b
    - No one point in the domain can be mapped to two different points
      in the codomain
      - Logically, you can't have a function that takes in one input and
        returns two different outputs
      - If f maps x -> y1 and -> y2, y1 = y2
      -[for all] x [element of] A y_{1},y_{2} [element of] B [f(x)=y_{1}
       [logical and] f(x)=y_{2} -> y_{1} = y_{2}]


3.5 TODO Types of Functions - Definition & Logical Statement
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - Injective Functions
  - Surjective Functions
  - Proof by Induction ([for all])
  - Proof by Contradiction ([angled dash][there exists])


3.6 Finite Automaton (Finite State Machine)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  - States are logical confirgurations
  - States are generally based upon input
  - Purpose of a state machine is to make a yes/no decision
