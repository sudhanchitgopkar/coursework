% Created 2021-01-25 Mon 12:17
% Intended LaTeX compiler: pdflatex
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\author{Sudhan Chitgopkar}
\date{\today}
\title{}
\hypersetup{
 pdfauthor={Sudhan Chitgopkar},
 pdftitle={},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 27.1 (Org mode 9.5)}, 
 pdflang={English}}
\begin{document}

\tableofcontents \clearpage\section{01.15.21 (File I/O)}
\label{sec:orgbf7e181}
\begin{itemize}
\item File I/O ex.
\begin{verbatim}
#include <fstream>

int main () {
  //opens file
  ifstream inClientFile("clients.dat", ios::in);

  //exits if file can't be opened
  if (!inClientFile) {
    cerr << "File could not be opened" << endl;
    exit(1);
  } //if

  //var declarations
  int account;
  string name;
  double balance;

 // displays each record in the file
 while (inClientFile >> account >> name >> balance) {
   outputLine(account,name,balance);
 } //while

}
\end{verbatim}
\end{itemize}
\section{01.25.21 (C++ Ch. 9)}
\label{sec:org69e17c1}
\subsection{Pass by Reference}
\label{sec:orgc38b68e}
\begin{itemize}
\item When dealing with very large objects, don't pass by copy due to the large overhead of copying. Instead, pass by reference
\item When passing by reference, use const if you don't want to modify the data members
\end{itemize}
\subsection{Destructors}
\label{sec:orge415567}
\begin{itemize}
\item Name of destructor is className\textasciitilde{}
\item Called implicitly when an object is destroyed
\item Takes no parameters, returns no value
\item No return type allowed in signature, not even void
\item Only one destructor allowed per class
\item Must be public
\item Destructors are called once a variable exits its scope
\item Static variables are destroyed after local variables, with global variables destroyed last
\item Objects are also destroyed in reverse order from their construction
\end{itemize}
\subsection{Const Objects}
\label{sec:org166eb5c}
\begin{itemize}
\item const objects must use const methods only
\item non-const objects may use both non-const and const methods
\end{itemize}
\section{01.21.21 (C++ Ch. 9)}
\label{sec:org1a95a55}
\subsection{Encapsulation}
\label{sec:orgc8f110f}
\begin{itemize}
\item Header files should not contain source code, it should only include prototypes in order to ensure proper information-hiding
\item Source code should be placed in a different cpp file, which pulls from the prototypes in the header file
\end{itemize}
\subsection{Include Guards}
\label{sec:org510a212}
\begin{itemize}
\item Consider the following classes: Student, Course, and Main
\begin{itemize}
\item Student uses Course
\item Main uses Student and Course
\item The main method would then look like:
\end{itemize}
\begin{verbatim}
  #include "student.h"
  #include "course.h"
\end{verbatim}
\begin{itemize}
\item student.h compiles properly, but an error is thrown when course.h tries to be included because it has already been included through Student.
\item To fix this, use header guards, as follows:
\end{itemize}
\begin{verbatim}
  #ifndef FILENAME_H
  #define FILENAME_H
\end{verbatim}
\item Include guards ensure that a prototype is not defined twice
\item The header guard should be put in header files that are used in multiple places
\end{itemize}
\subsection{Writing Classes}
\label{sec:orgea565f2}
\begin{itemize}
\item Begin by including the necessary header file
\item All methods and constructors must be preceded by the header file name and the scope resolution operator (::)
\end{itemize}
\subsection{Constructors \& Default Constructors}
\label{sec:org32a7906}
\begin{itemize}
\item Constructors can call other methods and do data-checking
\item Constructors can be called explicit with multiple parameters when the parameters are impossible to typecast, as follows:
\end{itemize}
\begin{verbatim}
int main () {
  explicit Time t (x = 0, y = 0, z = 0);
} //main
\end{verbatim}
\section{01.21.21 (C++ Ch. 3)}
\label{sec:org0e46bb2}
\subsection{Objects and Object Sizes}
\label{sec:org30ede00}
\begin{itemize}
\item An objects size will always be the sum of its data members. The size will not be affected by any methods that are called upon it.
\item Because of this, objects can quickly become very large in size.
\end{itemize}
\subsection{UML Diagrams}
\label{sec:org4ddf274}
\begin{itemize}
\item Classes are listed as individual boxes
\begin{itemize}
\item top box = class name
\item middle compartment = data members : data type
\item bottom compartment - methods and parameters
\begin{itemize}
\item - = private
\item + = public
\item \# = protected
\end{itemize}
\end{itemize}
\end{itemize}
\subsection{Constructors}
\label{sec:orgf5c5587}
\begin{itemize}
\item Explicit constructors can be used to prevent implicit typecasting, as seen below:
\end{itemize}
\begin{verbatim}
class Student {
  Student (int s) {

  } //constructor
} //Student

int main () {
  Student s {15}; //allowed, completes correctly
  Student c {'C'}; //typecasts automatically, should not occur
  //Note, () can be used in place of {} to construct objects
}
\end{verbatim}

\begin{itemize}
\item Ex. list initialization with an explicit constructor
\end{itemize}
\begin{verbatim}
explicit Account (std::string accountName) //explicit constructor
  : name{accountName} {
  //insert constructor code here
  }
\end{verbatim}
\section{01.19.21 (C++ Ch. 3)}
\label{sec:org79cddad}
A look at class creation
\begin{verbatim}
#include <iostream>
using namespace std;

//defining the class
class GradeBook {
  //holds all public vars, functions
  public:
  //public function
  void displayMessage() {
    cout << "Welcome to your Gradebook" << endl;
  } //displayMesage
} //GradeBook

//main method
int main () {
  //creates a GradeBook object
  GradeBook myGradeBook;
  //calls above created function on object
  myGradeBook.displayMessage();
}
\end{verbatim}

\begin{itemize}
\item Class functions and vars are, by default, private. The public keyword must be used to denote any public parts of a class.

\item Move implementations to a header file for use in main methods while separating out each file.

\item When using header files, use quotation marks around them to indicate that they're a file on your machine. Use angle brackets around things to include form the C std lib.

\item The purpose of const functions is to prevent the function from modifying the values of data members or objects.
\end{itemize}

\section{01.19.21 (C++ Ch. 2)}
\label{sec:org7c0ae27}
A look at some basic C++ code
\begin{verbatim}
#include <iostream> //enables program to output data

//main function begins program execution
int main () {
  //cout currently a function as a part of the std namespace
  std::cout << "Welcome to C++!\n";
  //above << is an insertion operator, overloaded from the bitwise left-shift

  return 0;
}
\end{verbatim}

A look at some higher level C++ code
\begin{verbatim}
#include <iostream>

int main () {

  int num1{0}; //list initialization
  int num2 = 0; //regular initialization
 //No difference between list & regular initializtion with primitive types.
 //List initialization should be used for UDTs.

  int sum{0}

  std::cin >> num1;
  std::cin >> num2;

  sum = num1 + num2;

  std::cout << sum << std::endl;
  //endl is helpful because it flushes the buffer
  //newline character does not
  return 0;
}
\end{verbatim}

A look at a common mistake
\begin{verbatim}
#include <iostream>

int main () {
  int x {5};

  if(x > 10); {
    std::cout << x "> 10" << std::endl;
  }
  //still prints output because of semicolon after if statement

  return 0;
}
\end{verbatim}
\end{document}
